<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RPC: &lt;small&gt;nlohmann::basic_json::&lt;/small&gt;basic_json</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RPC
   </div>
   <div id="projectbrief">EZ RPC C++ Windows/Linux interop</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2basic__json.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">&lt;small&gt;nlohmann::basic_json::&lt;/small&gt;basic_json</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md118"></a> </p><div class="fragment"><div class="line"><span class="comment">// (1)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(<span class="keyword">const</span> value_t v);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (2)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(<a class="code hl_typedef" href="namespacestd.html#a147badd87f1e15108e8dbee257b60b84">std::nullptr_t</a> = <span class="keyword">nullptr</span>) noexcept;</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (3)</span></div>
<div class="line">template&lt;typename CompatibleType&gt;</div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(CompatibleType&amp;&amp; val) noexcept(noexcept(</div>
<div class="line">           JSONSerializer&lt;U&gt;::to_json(<a class="code hl_namespace" href="namespacestd.html">std</a>::declval&lt;basic_json_t&amp;&gt;(),</div>
<div class="line">                                      <a class="code hl_namespace" href="namespacestd.html">std</a>::forward&lt;CompatibleType&gt;(val))));</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (4)</span></div>
<div class="line">template&lt;typename BasicJsonType&gt;</div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(const BasicJsonType&amp; val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (5)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(initializer_list_t init,</div>
<div class="line">           <span class="keywordtype">bool</span> type_deduction = true,</div>
<div class="line">           value_t manual_type = value_t::<a class="code hl_class" href="classarray.html">array</a>);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (6)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(size_type cnt, const <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp; val);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (7)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(iterator first, iterator last);</div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(const_iterator first, const_iterator last);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (8)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(const <a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp; other);</div>
<div class="line"> </div>
<div class="line"><span class="comment">// (9)</span></div>
<div class="line"><a class="code hl_class" href="classbasic__json.html">basic_json</a>(<a class="code hl_class" href="classbasic__json.html">basic_json</a>&amp;&amp; other) noexcept;</div>
<div class="ttc" id="aclassarray_html"><div class="ttname"><a href="classarray.html">array</a></div><div class="ttdef"><b>Definition</b> <a href="unit-regression1_8cpp_source.html#l01507">unit-regression1.cpp:1507</a></div></div>
<div class="ttc" id="aclassbasic__json_html"><div class="ttname"><a href="classbasic__json.html">basic_json</a></div><div class="ttdoc">namespace for Niels Lohmann</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00097">json.hpp:99</a></div></div>
<div class="ttc" id="anamespacestd_html"><div class="ttname"><a href="namespacestd.html">std</a></div><div class="ttdef"><b>Definition</b> <a href="iteration__proxy_8hpp_source.html#l00213">iteration_proxy.hpp:214</a></div></div>
<div class="ttc" id="anamespacestd_html_a147badd87f1e15108e8dbee257b60b84"><div class="ttname"><a href="namespacestd.html#a147badd87f1e15108e8dbee257b60b84">std::nullptr_t</a></div><div class="ttdeci">decltype(nullptr) nullptr_t</div><div class="ttdef"><b>Definition</b> <a href="doctest_8h_source.html#l00523">doctest.h:523</a></div></div>
</div><!-- fragment --><ol type="1">
<li>Create an empty JSON value with a given type. The value will be default initialized with an empty value which depends on the type:</li>
</ol>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">Value type   </th><th class="markdownTableHeadNone">initial value    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">null   </td><td class="markdownTableBodyNone"><code>#!json null</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">boolean   </td><td class="markdownTableBodyNone"><code>#!json false</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone"><code>#!json ""</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">number   </td><td class="markdownTableBodyNone"><code>#!json 0</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">object   </td><td class="markdownTableBodyNone"><code>#!json {}</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">array   </td><td class="markdownTableBodyNone"><code>#!json []</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">binary   </td><td class="markdownTableBodyNone">empty array   </td></tr>
</table>
<p>The postcondition of this constructor can be restored by calling <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2clear.html"><code>clear()</code></a>.</p>
<ol type="1">
<li>Create a <code>#!json null</code> JSON value. It either takes a null pointer as parameter (explicitly creating <code>#!json null</code>) or no parameter (implicitly creating <code>#!json null</code>). The passed null pointer itself is not read &ndash; it is only used to choose the right constructor.</li>
<li><p class="startli">This is a "catch all" constructor for all compatible JSON types; that is, types for which a <code>to_json()</code> method exists. The constructor forwards the parameter <code>val</code> to that method (to <code>json_serializer&lt;U&gt;::to_json</code> method with <code>U = uncvref_t&lt;CompatibleType&gt;</code>, to be exact).</p>
<p class="startli">Template type <code>CompatibleType</code> includes, but is not limited to, the following types:</p><ul>
<li><b>arrays</b>: <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2array__t.html"><code>array_t</code></a> and all kinds of compatible containers such as <code>std::vector</code>, <code>std::deque</code>, <code>std::list</code>, <code>std::forward_list</code>, <code>std::array</code>, <code>std::valarray</code>, <code>std::set</code>, <code>std::unordered_set</code>, <code>std::multiset</code>, and <code>std::unordered_multiset</code> with a <code>value_type</code> from which a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> value can be constructed.</li>
<li><b>objects</b>: <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2object__t.html"><code>object_t</code></a> and all kinds of compatible associative containers such as <code>std::map</code>, <code>std::unordered_map</code>, <code>std::multimap</code>, and <code>std::unordered_multimap</code> with a <code>key_type</code> compatible to <code>string_t</code> and a <code>value_type</code> from which a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> value can be constructed.</li>
<li><b>strings</b>: <code>string_t</code>, string literals, and all compatible string containers can be used.</li>
<li><b>numbers</b>: <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2number__integer__t.html"><code>number_integer_t</code></a>, <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2number__unsigned__t.html"><code>number_unsigned_t</code></a>, <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2number__float__t.html"><code>number_float_t</code></a>, and all convertible number types such as <code>int</code>, <code>size_t</code>, <code>int64_t</code>, <code>float</code> or <code>double</code> can be used.</li>
<li><b>boolean</b>: <code>boolean_t</code> / <code>bool</code> can be used.</li>
<li><b>binary</b>: <code>binary_t</code> / <code>std::vector&lt;uint8_t&gt;</code> may be used; unfortunately because string literals cannot be distinguished from binary character arrays by the C++ type system, all types compatible with <code>const char*</code> will be directed to the string constructor instead. This is both for backwards compatibility, and due to the fact that a binary type is not a standard JSON type.</li>
</ul>
<p class="startli">See the examples below.</p>
</li>
<li><p class="startli">This is a constructor for existing <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> types. It does not hijack copy/move constructors, since the parameter has different template arguments than the current ones.</p>
<p class="startli">The constructor tries to convert the internal <code>m_value</code> of the parameter.</p>
</li>
<li><p class="startli">Creates a JSON value of type array or object from the passed initializer list <code>init</code>. In case <code>type_deduction</code> is <code>#!cpp true</code> (default), the type of the JSON value to be created is deducted from the initializer list <code>init</code> according to the following rules:</p><ol type="a">
<li>If the list is empty, an empty JSON object value <code>{}</code> is created.</li>
<li>If the list consists of pairs whose first element is a string, a JSON object value is created where the first elements of the pairs are treated as keys and the second elements are as values.</li>
<li>In all other cases, an array is created.</li>
</ol>
<p class="startli">The rules aim to create the best fit between a C++ initializer list and JSON values. The rationale is as follows:</p><ol type="a">
<li>The empty initializer list is written as <code>#!cpp {}</code> which is exactly an empty JSON object.</li>
<li>C++ has no way of describing mapped types other than to list a list of pairs. As JSON requires that keys must be of type string, rule 2 is the weakest constraint one can pose on initializer lists to interpret them as an object.</li>
<li>In all other cases, the initializer list could not be interpreted as JSON object type, so interpreting it as JSON array type is safe.</li>
</ol>
<p class="startli">With the rules described above, the following JSON values cannot be expressed by an initializer list:</p><ul>
<li>the empty array (<code>#!json []</code>): use <code><a class="el" href="_load_test_8cpp.html#a792d6eeeb0acc4674d47aa40992d6014">array(initializer_list_t)</a></code> with an empty initializer list in this case</li>
<li>arrays whose elements satisfy rule 2: use <code><a class="el" href="_load_test_8cpp.html#a792d6eeeb0acc4674d47aa40992d6014">array(initializer_list_t)</a></code> with the same initializer list in this case</li>
</ul>
<p class="startli">Function <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2array.html"><code>array()</code></a> and <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2api_2basic__json_2object.html"><code>object()</code></a> force array and object creation from initializer lists, respectively.</p>
</li>
<li>Constructs a JSON array value by creating <code>cnt</code> copies of a passed value. In case <code>cnt</code> is <code>0</code>, an empty array is created.</li>
<li>Constructs the JSON value with the contents of the range <code>[first, last)</code>. The semantics depends on the different types a JSON value can have:<ul>
<li>In case of a <code>#!json null</code> type, <a href="../../home/exceptions.md#jsonexceptioninvalid_iterator206">invalid_iterator.206</a> is thrown.</li>
<li>In case of other primitive types (number, boolean, or string), <code>first</code> must be <code>begin()</code> and <code>last</code> must be <code>end()</code>. In this case, the value is copied. Otherwise, <a href="../../home/exceptions.md#jsonexceptioninvalid_iterator204"><code>invalid_iterator.204</code></a> is thrown.</li>
<li>In case of structured types (array, object), the constructor behaves as similar versions for <code>std::vector</code> or <code>std::map</code>; that is, a JSON array or object is constructed from the values in the range.</li>
</ul>
</li>
<li>Creates a copy of a given JSON value.</li>
<li>Move constructor. Constructs a JSON value with the contents of the given value <code>other</code> using move semantics. It "steals" the resources from <code>other</code> and leaves it as JSON <code>#!json null</code> value.</li>
</ol>
<h1><a class="anchor" id="autotoc_md119"></a>
Template parameters</h1>
<p><code>CompatibleType</code> : a type such that: </p><pre class="fragment">- `CompatibleType` is not derived from `std::istream`,
- `CompatibleType` is not `basic_json` (to avoid hijacking copy/move constructors),
- `CompatibleType` is not a different `basic_json` type (i.e. with different template arguments)
- `CompatibleType` is not a `basic_json` nested type (e.g., `json_pointer`, `iterator`, etc.)
- `json_serializer&lt;U&gt;` (with `U = uncvref_t&lt;CompatibleType&gt;`) has a `to_json(basic_json_t&amp;, CompatibleType&amp;&amp;)`
   method
</pre><p> <code>BasicJsonType</code>: : a type such that: </p><pre class="fragment">- `BasicJsonType` is a `basic_json` type.
- `BasicJsonType` has different template arguments than `basic_json_t`.
</pre><p> <code>U</code>: : <code>uncvref_t&lt;CompatibleType&gt;</code></p>
<h1><a class="anchor" id="autotoc_md120"></a>
Parameters</h1>
<p><code>v</code> (in) : the type of the value to create</p>
<p><code>val</code> (in) : the value to be forwarded to the respective constructor</p>
<p><code>init</code> (in) : initializer list with JSON values</p>
<p><code>type_deduction</code> (in) : internal parameter; when set to <code>#!cpp true</code>, the type of the JSON value is deducted from the initializer list <code>init</code>; when set to <code>#!cpp false</code>, the type provided via <code>manual_type</code> is forced. This mode is used by the functions <code><a class="el" href="_load_test_8cpp.html#a792d6eeeb0acc4674d47aa40992d6014">array(initializer_list_t)</a></code> and <code><a class="el" href="classobject.html">object(initializer_list_t)</a></code>.</p>
<p><code>manual_type</code> (in) : internal parameter; when <code>type_deduction</code> is set to <code>#!cpp false</code>, the created JSON value will use the provided type (only <code>value_t::array</code> and <code>value_t::object</code> are valid); when <code>type_deduction</code> is set to <code>#!cpp true</code>, this parameter has no effect</p>
<p><code>cnt</code> (in) : the number of JSON copies of <code>val</code> to create</p>
<p><code>first</code> (in) : begin of the range to copy from (included)</p>
<p><code>last</code> (in) : end of the range to copy from (excluded)</p>
<p><code>other</code> (in) : the JSON value to copy/move</p>
<h1><a class="anchor" id="autotoc_md121"></a>
Exception safety</h1>
<ol type="1">
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>No-throw guarantee: this constructor never throws exceptions.</li>
<li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no <code>to_json()</code> function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Depends on the called constructor. For types directly supported by the library (i.e., all types for which no <code>to_json()</code> function was provided), strong guarantee holds: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>Strong guarantee: if an exception is thrown, there are no changes to any JSON value.</li>
<li>No-throw guarantee: this constructor never throws exceptions.</li>
</ol>
<h1><a class="anchor" id="autotoc_md122"></a>
Exceptions</h1>
<ol type="1">
<li>(none)</li>
<li>The function does not throw exceptions.</li>
<li>(none)</li>
<li>(none)</li>
<li>The function can throw the following exceptions:<ul>
<li>Throws <a href="../../home/exceptions.md#jsonexceptiontype_error301"><code>type_error.301</code></a> if <code>type_deduction</code> is <code>#!cpp false</code>, <code>manual_type</code> is <code>value_t::object</code>, but <code>init</code> contains an element which is not a pair whose first element is a string. In this case, the constructor could not create an object. If <code>type_deduction</code> would have been <code>#!cpp true</code>, an array would have been created. See <code><a class="el" href="classobject.html">object(initializer_list_t)</a></code> for an example.</li>
</ul>
</li>
<li>(none)</li>
<li>The function can throw the following exceptions:<ul>
<li>Throws <a href="../../home/exceptions.md#jsonexceptioninvalid_iterator201"><code>invalid_iterator.201</code></a> if iterators <code>first</code> and <code>last</code> are not compatible (i.e., do not belong to the same JSON value). In this case, the range <code>[first, last)</code> is undefined.</li>
<li>Throws <a href="../../home/exceptions.md#jsonexceptioninvalid_iterator204"><code>invalid_iterator.204</code></a> if iterators <code>first</code> and <code>last</code> belong to a primitive type (number, boolean, or string), but <code>first</code> does not point to the first element anymore. In this case, the range <code>[first, last)</code> is undefined. See example code below.</li>
<li>Throws <a href="../../home/exceptions.md#jsonexceptioninvalid_iterator206"><code>invalid_iterator.206</code></a> if iterators <code>first</code> and <code>last</code> belong to a <code>#!json null</code> value. In this case, the range <code>[first, last)</code> is undefined.</li>
</ul>
</li>
<li>(none)</li>
<li>The function does not throw exceptions.</li>
</ol>
<h1><a class="anchor" id="autotoc_md123"></a>
Complexity</h1>
<ol type="1">
<li>Constant.</li>
<li>Constant.</li>
<li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code> method.</li>
<li>Usually linear in the size of the passed <code>val</code>, also depending on the implementation of the called <code>to_json()</code> method.</li>
<li>Linear in the size of the initializer list <code>init</code>.</li>
<li>Linear in <code>cnt</code>.</li>
<li>Linear in distance between <code>first</code> and <code>last</code>.</li>
<li>Linear in the size of <code>other</code>.</li>
<li>Constant.</li>
</ol>
<h1><a class="anchor" id="autotoc_md124"></a>
Notes</h1>
<ul>
<li><p class="startli">Overload 5:</p>
<p class="startli">!!! note "Empty initializer list" </p><pre class="fragment">When used without parentheses around an empty initializer list, `basic_json()` is called instead of this
function, yielding the JSON `#!json null` value.
</pre></li>
<li><p class="startli">Overload 7:</p>
<p class="startli">!!! info "Preconditions" </p><pre class="fragment">- Iterators `first` and `last` must be initialized. **This precondition is enforced with a
  [runtime assertion](../../features/assertions.md).
- Range `[first, last)` is valid. Usually, this precondition cannot be checked efficiently. Only certain edge
  cases are detected; see the description of the exceptions above. A violation of this precondition yields
  undefined behavior.
</pre><p> !!! danger "Runtime assertion" </p><pre class="fragment">A precondition is enforced with a [runtime assertion](../../features/assertions.md).
</pre></li>
<li><p class="startli">Overload 8:</p>
<p class="startli">!!! info "Postcondition" </p><pre class="fragment">`#!cpp *this == other`
</pre></li>
<li><p class="startli">Overload 9:</p>
<p class="startli">!!! info "Postconditions" </p><pre class="fragment">- `#!cpp `*this` has the same value as `other` before the call.
- `other` is a JSON `#!json null` value
</pre> </li>
</ul>
<h1><a class="anchor" id="autotoc_md125"></a>
Examples</h1>
<p>??? example "Example: (1) create an empty value with a given type" </p><pre class="fragment">The following code shows the constructor for different `value_t` values.

```cpp
--8&lt;-- "examples/basic_json__value_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__value_t.output"
```
</pre><p> ??? example "Example: (2) create a `#!json null` object" </p><pre class="fragment">The following code shows the constructor with and without a null pointer parameter.

```cpp
--8&lt;-- "examples/basic_json__nullptr_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__nullptr_t.output"
```
</pre><p> ??? example "Example: (3) create a JSON value from compatible types" </p><pre class="fragment">The following code shows the constructor with several compatible types.

```cpp
--8&lt;-- "examples/basic_json__CompatibleType.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__CompatibleType.output"
```

Note the output is platform-dependent.
</pre><p> ??? example "Example: (5) create a container (array or object) from an initializer list" </p><pre class="fragment">The example below shows how JSON values are created from initializer lists.

```cpp
--8&lt;-- "examples/basic_json__list_init_t.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__list_init_t.output"
```
</pre><p> ??? example "Example: (6) construct an array with count copies of given value" </p><pre class="fragment">The following code shows examples for creating arrays with several copies of a given value.

```cpp
--8&lt;-- "examples/basic_json__size_type_basic_json.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__size_type_basic_json.output"
```
</pre><p> ??? example "Example: (7) construct a JSON container given an iterator range" </p><pre class="fragment">The example below shows several ways to create JSON values by specifying a subrange with iterators.

```cpp
--8&lt;-- "examples/basic_json__InputIt_InputIt.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__InputIt_InputIt.output"
```
</pre><p> ??? example "Example: (8) copy constructor" </p><pre class="fragment">The following code shows an example for the copy constructor.

```cpp
--8&lt;-- "examples/basic_json__basic_json.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__basic_json.output"
```
</pre><p> ??? example "Example: (9) move constructor" </p><pre class="fragment">The code below shows the move constructor explicitly called via `std::move`.

```cpp
--8&lt;-- "examples/basic_json__moveconstructor.cpp"
```

Output:

```json
--8&lt;-- "examples/basic_json__moveconstructor.output"
```
</pre> <h1><a class="anchor" id="autotoc_md126"></a>
Version history</h1>
<ol type="1">
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 2.1.0.</li>
<li>Since version 3.2.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0.</li>
<li>Since version 1.0.0. </li>
</ol>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
