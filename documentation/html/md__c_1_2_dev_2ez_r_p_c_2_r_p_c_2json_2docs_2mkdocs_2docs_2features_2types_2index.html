<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.10.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>RPC: Types</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">RPC
   </div>
   <div id="projectbrief">EZ RPC C++ Windows/Linux interop</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.10.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2features_2types_2index.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Types</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p><a class="anchor" id="autotoc_md1433"></a> This page gives an overview how JSON values are stored and how this can be configured.</p>
<h1><a class="anchor" id="autotoc_md1434"></a>
Overview</h1>
<p>By default, JSON values are stored as follows:</p>
<table class="markdownTable">
<tr class="markdownTableHead">
<th class="markdownTableHeadNone">JSON type   </th><th class="markdownTableHeadNone">C++ type    </th></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">object   </td><td class="markdownTableBodyNone"><code>std::map&lt;std::string, <a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a>&gt;</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">array   </td><td class="markdownTableBodyNone"><code>std::vector&lt;<a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a>&gt;</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">null   </td><td class="markdownTableBodyNone"><code><a class="el" href="namespacestd.html#a147badd87f1e15108e8dbee257b60b84">std::nullptr_t</a></code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">string   </td><td class="markdownTableBodyNone"><code>std::string</code>    </td></tr>
<tr class="markdownTableRowOdd">
<td class="markdownTableBodyNone">boolean   </td><td class="markdownTableBodyNone"><code>bool</code>    </td></tr>
<tr class="markdownTableRowEven">
<td class="markdownTableBodyNone">number   </td><td class="markdownTableBodyNone"><code>std::int64_t</code>, <code>std::uint64_t</code>, and <code>double</code>   </td></tr>
</table>
<p>Note there are three different types for numbers - when parsing JSON text, the best fitting type is chosen.</p>
<h1><a class="anchor" id="autotoc_md1435"></a>
Storage</h1>
<div class="fragment"><div class="line">enum value_t {</div>
<div class="line">    null</div>
<div class="line">    object</div>
<div class="line">    array</div>
<div class="line">    string</div>
<div class="line">    boolean</div>
<div class="line">    number_integer</div>
<div class="line">    number_unsigned</div>
<div class="line">    number_float</div>
<div class="line">    binary</div>
<div class="line">    discarded</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class json_value &lt;&lt; (U,orchid) &gt;&gt; {</div>
<div class="line">    object_t* object</div>
<div class="line">    array_t* array</div>
<div class="line">    string_t* string</div>
<div class="line">    binary_t* binary</div>
<div class="line">    boolean_t boolean</div>
<div class="line">    number_integer_t number_integer</div>
<div class="line">    number_unsigned_t number_unsigned</div>
<div class="line">    number_float_t number_float</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">class basic_json {</div>
<div class="line">    -- type and value --</div>
<div class="line">    value_t m_type</div>
<div class="line">    json_value m_value</div>
<div class="line">    -- derived types --</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; object_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; array_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; binary_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; boolean_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; number_integer_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; number_unsigned_t</div>
<div class="line">    + &lt;u&gt;typedef&lt;/u&gt; number_float_t</div>
<div class="line">}</div>
<div class="line"> </div>
<div class="line">basic_json .. json_value</div>
<div class="line">basic_json .. value_t</div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1436"></a>
Template arguments</h1>
<p>The data types to store a JSON value are derived from the template arguments passed to class <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code>:</p>
<div class="fragment"><div class="line"><span class="keyword">template</span>&lt;</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span> V, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class </span>ObjectType = std::map,</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U, <span class="keyword">typename</span>... Args&gt; <span class="keyword">class </span>ArrayType = std::vector,</div>
<div class="line">    <span class="keyword">class </span>StringType = std::string,</div>
<div class="line">    <span class="keyword">class </span>BooleanType = bool,</div>
<div class="line">    <span class="keyword">class </span>NumberIntegerType = std::int64_t,</div>
<div class="line">    <span class="keyword">class </span>NumberUnsignedType = std::uint64_t,</div>
<div class="line">    <span class="keyword">class </span>NumberFloatType = double,</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt; <span class="keyword">class </span>AllocatorType = std::allocator,</div>
<div class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> SFINAE = <span class="keywordtype">void</span>&gt; <span class="keyword">class </span>JSONSerializer = <a class="code hl_struct" href="structadl__serializer.html">adl_serializer</a>,</div>
<div class="line">    <span class="keyword">class </span>BinaryType = std::vector&lt;std::uint8_t&gt;</div>
<div class="line">&gt;</div>
<div class="line"><span class="keyword">class </span><a class="code hl_class" href="classbasic__json.html">basic_json</a>;</div>
<div class="ttc" id="aclassbasic__json_html"><div class="ttname"><a href="classbasic__json.html">basic_json</a></div><div class="ttdoc">namespace for Niels Lohmann</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00097">json.hpp:99</a></div></div>
<div class="ttc" id="astructadl__serializer_html"><div class="ttname"><a href="structadl__serializer.html">adl_serializer</a></div><div class="ttdoc">namespace for Niels Lohmann</div><div class="ttdef"><b>Definition</b> <a href="adl__serializer_8hpp_source.html#l00022">adl_serializer.hpp:23</a></div></div>
</div><!-- fragment --><p>Type <code>json</code> is an alias for <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a>&lt;&gt;</code> and uses the default types.</p>
<p>From the template arguments, the following types are derived:</p>
<div class="fragment"><div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a> = std::less&lt;&gt;;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#a67bb0d6dfaf1709d918b7107f5b94a3d">object_t</a> = ObjectType&lt;StringType, <a class="code hl_function" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json</a>, <a class="code hl_typedef" href="classbasic__json.html#af12040e0663db54840d73d363979643a">object_comparator_t</a>,</div>
<div class="line">                   AllocatorType&lt;std::pair&lt;const StringType, basic_json&gt;&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#a60644b7dccc409e6b367361d37841333">array_t</a> = ArrayType&lt;basic_json, AllocatorType&lt;basic_json&gt;&gt;;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">string_t</a> = StringType;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">boolean_t</a> = BooleanType;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">number_integer_t</a> = NumberIntegerType;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">number_unsigned_t</a> = NumberUnsignedType;</div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">number_float_t</a> = NumberFloatType;</div>
<div class="line"> </div>
<div class="line"><span class="keyword">using </span><a class="code hl_typedef" href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">binary_t</a> = <a class="code hl_class" href="classnlohmann_1_1byte__container__with__subtype.html">nlohmann::byte_container_with_subtype&lt;BinaryType&gt;</a>;</div>
<div class="ttc" id="aclassbasic__json_html_a4c1b5ea434b48cf31097617bb1c1ca1e"><div class="ttname"><a href="classbasic__json.html#a4c1b5ea434b48cf31097617bb1c1ca1e">basic_json::binary_t</a></div><div class="ttdeci">nlohmann::byte_container_with_subtype&lt; BinaryType &gt; binary_t</div><div class="ttdoc">a type for a packed binary type</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00365">json.hpp:365</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a60644b7dccc409e6b367361d37841333"><div class="ttname"><a href="classbasic__json.html#a60644b7dccc409e6b367361d37841333">basic_json::array_t</a></div><div class="ttdeci">ArrayType&lt; basic_json, AllocatorType&lt; basic_json &gt; &gt; array_t</div><div class="ttdoc">a type for an array</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00341">json.hpp:341</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a67bb0d6dfaf1709d918b7107f5b94a3d"><div class="ttname"><a href="classbasic__json.html#a67bb0d6dfaf1709d918b7107f5b94a3d">basic_json::object_t</a></div><div class="ttdeci">ObjectType&lt; StringType, basic_json, default_object_comparator_t, AllocatorType&lt; std::pair&lt; const StringType, basic_json &gt; &gt; &gt; object_t</div><div class="ttdoc">a type for an object</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00333">json.hpp:333</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a80a229dbc84c1334171ce9c49c873c56"><div class="ttname"><a href="classbasic__json.html#a80a229dbc84c1334171ce9c49c873c56">basic_json::number_float_t</a></div><div class="ttdeci">NumberFloatType number_float_t</div><div class="ttdoc">a type for a number (floating-point)</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00361">json.hpp:361</a></div></div>
<div class="ttc" id="aclassbasic__json_html_a9301890c48e9b957edc07f9eb767bd10"><div class="ttname"><a href="classbasic__json.html#a9301890c48e9b957edc07f9eb767bd10">basic_json::boolean_t</a></div><div class="ttdeci">BooleanType boolean_t</div><div class="ttdoc">a type for a boolean</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00349">json.hpp:349</a></div></div>
<div class="ttc" id="aclassbasic__json_html_aba48b0bdee31228a4e19b7c040b6d2a5"><div class="ttname"><a href="classbasic__json.html#aba48b0bdee31228a4e19b7c040b6d2a5">basic_json::number_integer_t</a></div><div class="ttdeci">NumberIntegerType number_integer_t</div><div class="ttdoc">a type for a number (integer)</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00353">json.hpp:353</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ac8c9cde32146e6c343e1960aefc11fba"><div class="ttname"><a href="classbasic__json.html#ac8c9cde32146e6c343e1960aefc11fba">basic_json::string_t</a></div><div class="ttdeci">StringType string_t</div><div class="ttdoc">a type for a string</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00345">json.hpp:345</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ae2d5bc42270881ed3e219e8b1456fec5"><div class="ttname"><a href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json::basic_json</a></div><div class="ttdeci">basic_json(const value_t v)</div><div class="ttdoc">create an empty value with a given type</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00815">json.hpp:815</a></div></div>
<div class="ttc" id="aclassbasic__json_html_ae8505b599e706768a1e0bd6718cc7117"><div class="ttname"><a href="classbasic__json.html#ae8505b599e706768a1e0bd6718cc7117">basic_json::number_unsigned_t</a></div><div class="ttdeci">NumberUnsignedType number_unsigned_t</div><div class="ttdoc">a type for a number (unsigned)</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00357">json.hpp:357</a></div></div>
<div class="ttc" id="aclassbasic__json_html_af12040e0663db54840d73d363979643a"><div class="ttname"><a href="classbasic__json.html#af12040e0663db54840d73d363979643a">basic_json::object_comparator_t</a></div><div class="ttdeci">detail::actual_object_comparator_t&lt; basic_json &gt; object_comparator_t</div><div class="ttdoc">object key comparator type</div><div class="ttdef"><b>Definition</b> <a href="include_2nlohmann_2json_8hpp_source.html#l00369">json.hpp:369</a></div></div>
<div class="ttc" id="aclassnlohmann_1_1byte__container__with__subtype_html"><div class="ttname"><a href="classnlohmann_1_1byte__container__with__subtype.html">nlohmann::byte_container_with_subtype</a></div><div class="ttdoc">an internal type for a backed binary type</div><div class="ttdef"><b>Definition</b> <a href="json__v3__10__5_8hpp_source.html#l04972">json_v3_10_5.hpp:4973</a></div></div>
</div><!-- fragment --><h1><a class="anchor" id="autotoc_md1437"></a>
Objects</h1>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> describes JSON objects as follows:</p>
<blockquote class="doxtable">
<p>&zwj;An object is an unordered collection of zero or more name/value pairs, where a name is a string and a value is a string, number, boolean, null, object, or array. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md1438"></a>
Default type</h2>
<p>With the default values for <em>ObjectType</em> (<code>std::map</code>), <em>StringType</em> (<code>std::string</code>), and <em>AllocatorType</em> (<code>std::allocator</code>), the default value for <code>object_t</code> is:</p>
<div class="fragment"><div class="line">std::map&lt;</div>
<div class="line">  std::string, <span class="comment">// key_type</span></div>
<div class="line">  <a class="code hl_function" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json</a>, <span class="comment">// value_type</span></div>
<div class="line">  std::less&lt;&gt;, <span class="comment">// key_compare</span></div>
<div class="line">  std::allocator&lt;std::pair&lt;const std::string, basic_json&gt;&gt; <span class="comment">// allocator_type</span></div>
<div class="line">&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1439"></a>
Behavior</h2>
<p>The choice of <code>object_t</code> influences the behavior of the JSON class. With the default type, objects have the following behavior:</p>
<ul>
<li>When all names are unique, objects will be interoperable in the sense that all software implementations receiving that object will agree on the name-value mappings.</li>
<li>When the names within an object are not unique, it is unspecified which one of the values for a given key will be chosen. For instance, <code>#!json {"key": 2, "key": 1}</code> could be equal to either <code>#!json {"key": 1}</code> or <code>#!json {"key": 2}</code>.</li>
<li>Internally, name/value pairs are stored in lexicographical order of the names. Objects will also be serialized (see <code>dump</code>) in this order. For instance, both <code>#!json {"b": 1, "a": 2}</code> and <code>#!json {"a": 2, "b": 1}</code> will be stored and serialized as <code>#!json {"a": 2, "b": 1}</code>.</li>
<li>When comparing objects, the order of the name/value pairs is irrelevant. This makes objects interoperable in the sense that they will not be affected by these differences. For instance, <code>#!json {"b": 1, "a": 2}</code> and <code>#!json {"a": 2, "b": 1}</code> will be treated as equal.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1440"></a>
Key order</h2>
<p>The order name/value pairs are added to the object is <em>not</em> preserved by the library. Therefore, iterating an object may return name/value pairs in a different order than they were originally stored. In fact, keys will be traversed in alphabetical order as <code>std::map</code> with <code>std::less</code> is used by default. Please note this behavior conforms to <a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a>, because any order implements the specified "unordered" nature of JSON objects.</p>
<h2><a class="anchor" id="autotoc_md1441"></a>
Limits</h2>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> specifies:</p>
<blockquote class="doxtable">
<p>&zwj;An implementation may set limits on the maximum depth of nesting. </p>
</blockquote>
<p>In this class, the object's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON object.</p>
<h2><a class="anchor" id="autotoc_md1442"></a>
Storage</h2>
<p>Objects are stored as pointers in a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> type. That is, for any access to object values, a pointer of type <code>object_t*</code> must be dereferenced.</p>
<h1><a class="anchor" id="autotoc_md1443"></a>
Arrays</h1>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> describes JSON arrays as follows:</p>
<blockquote class="doxtable">
<p>&zwj;An array is an ordered sequence of zero or more values. </p>
</blockquote>
<h2><a class="anchor" id="autotoc_md1444"></a>
Default type</h2>
<p>With the default values for <em>ArrayType</em> (<code>std::vector</code>) and <em>AllocatorType</em> (<code>std::allocator</code>), the default value for <code>array_t</code> is:</p>
<div class="fragment"><div class="line">std::vector&lt;</div>
<div class="line">  <a class="code hl_function" href="classbasic__json.html#ae2d5bc42270881ed3e219e8b1456fec5">basic_json</a>, <span class="comment">// value_type</span></div>
<div class="line">  std::allocator&lt;basic_json&gt; <span class="comment">// allocator_type</span></div>
<div class="line">&gt;</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md1445"></a>
Limits</h2>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> specifies:</p>
<blockquote class="doxtable">
<p>&zwj;An implementation may set limits on the maximum depth of nesting. </p>
</blockquote>
<p>In this class, the array's limit of nesting is not explicitly constrained. However, a maximum depth of nesting may be introduced by the compiler or runtime environment. A theoretical limit can be queried by calling the <code>max_size</code> function of a JSON array.</p>
<h2><a class="anchor" id="autotoc_md1446"></a>
Storage</h2>
<p>Arrays are stored as pointers in a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> type. That is, for any access to array values, a pointer of type <code>array_t*</code> must be dereferenced.</p>
<h1><a class="anchor" id="autotoc_md1447"></a>
Strings</h1>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> describes JSON strings as follows:</p>
<blockquote class="doxtable">
<p>&zwj;A string is a sequence of zero or more Unicode characters. </p>
</blockquote>
<p>Unicode values are split by the JSON class into byte-sized characters during deserialization.</p>
<h2><a class="anchor" id="autotoc_md1448"></a>
Default type</h2>
<p>With the default values for <em>StringType</em> (<code>std::string</code>), the default value for <code>string_t</code> is <code>#!cpp std::string</code>.</p>
<h2><a class="anchor" id="autotoc_md1449"></a>
Encoding</h2>
<p>Strings are stored in UTF-8 encoding. Therefore, functions like <code>std::string::size()</code> or <code>std::string::length()</code> return the number of <b>bytes</b> in the string rather than the number of characters or glyphs.</p>
<h2><a class="anchor" id="autotoc_md1450"></a>
String comparison</h2>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> states:</p>
<blockquote class="doxtable">
<p>&zwj;Software implementations are typically required to test names of object members for equality. Implementations that transform the textual representation into sequences of Unicode code units and then perform the comparison numerically, code unit by code unit, are interoperable in the sense that implementations will agree in all cases on equality or inequality of two strings. For example, implementations that compare strings with escaped characters unconverted may incorrectly find that <code>"a\\b"</code> and <code>"a\u005Cb"</code> are not equal. </p>
</blockquote>
<p>This implementation is interoperable as it does compare strings code unit by code unit.</p>
<h2><a class="anchor" id="autotoc_md1451"></a>
Storage</h2>
<p>String values are stored as pointers in a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> type. That is, for any access to string values, a pointer of type <code>string_t*</code> must be dereferenced.</p>
<h1><a class="anchor" id="autotoc_md1452"></a>
Booleans</h1>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> implicitly describes a boolean as a type which differentiates the two literals <code>true</code> and <code>false</code>.</p>
<h2><a class="anchor" id="autotoc_md1453"></a>
Default type</h2>
<p>With the default values for <em>BooleanType</em> (<code>#!cpp bool</code>), the default value for <code>boolean_t</code> is <code>#!cpp bool</code>.</p>
<h2><a class="anchor" id="autotoc_md1454"></a>
Storage</h2>
<p>Boolean values are stored directly inside a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> type.</p>
<h1><a class="anchor" id="autotoc_md1455"></a>
Numbers</h1>
<p>See the <a class="el" href="md__c_1_2_dev_2ez_r_p_c_2_r_p_c_2json_2docs_2mkdocs_2docs_2features_2types_2number__handling.html">number handling</a> article for a detailed discussion on how numbers are handled by this library.</p>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> describes numbers as follows:</p>
<blockquote class="doxtable">
<p>&zwj;The representation of numbers is similar to that used in most programming languages. A number is represented in base 10 using decimal digits. It contains an integer component that may be prefixed with an optional minus sign, which may be followed by a fraction part and/or an exponent part. Leading zeros are not allowed. (...) Numeric values that cannot be represented in the grammar below (such as Infinity and NaN) are not permitted. </p>
</blockquote>
<p>This description includes both integer and floating-point numbers. However, C++ allows more precise storage if it is known whether the number is a signed integer, an unsigned integer or a floating-point number. Therefore, three different types, <code>number_integer_t</code>, <code>number_unsigned_t</code>, and <code>number_float_t</code> are used.</p>
<h2><a class="anchor" id="autotoc_md1456"></a>
Default types</h2>
<p>With the default values for <em>NumberIntegerType</em> (<code>std::int64_t</code>), the default value for <code>number_integer_t</code> is <code>std::int64_t</code>. With the default values for <em>NumberUnsignedType</em> (<code>std::uint64_t</code>), the default value for <code>number_unsigned_t</code> is <code>std::uint64_t</code>. With the default values for <em>NumberFloatType</em> (<code>#!cpp double</code>), the default value for <code>number_float_t</code> is <code>#!cpp double</code>.</p>
<h2><a class="anchor" id="autotoc_md1457"></a>
Default behavior</h2>
<ul>
<li>The restrictions about leading zeros is not enforced in C++. Instead, leading zeros in integer literals lead to an interpretation as octal number. Internally, the value will be stored as decimal number. For instance, the C++ integer literal <code>#!c 010</code> will be serialized to <code>#!c 8</code>. During deserialization, leading zeros yield an error.</li>
<li>Not-a-number (NaN) values will be serialized to <code>#!json null</code>.</li>
</ul>
<h2><a class="anchor" id="autotoc_md1458"></a>
Limits</h2>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> specifies:</p>
<blockquote class="doxtable">
<p>&zwj;An implementation may set limits on the range and precision of numbers. </p>
</blockquote>
<p>When the default type is used, the maximal integer number that can be stored is <code>#!c 9223372036854775807</code> (<code>INT64_MAX</code>) and the minimal integer number that can be stored is <code>#!c -9223372036854775808</code> (<code>INT64_MIN</code>). Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as <code>number_unsigned_t</code> or <code>number_float_t</code>.</p>
<p>When the default type is used, the maximal unsigned integer number that can be stored is <code>#!c 18446744073709551615</code> (<code>UINT64_MAX</code>) and the minimal integer number that can be stored is <code>#!c 0</code>. Integer numbers that are out of range will yield over/underflow when used in a constructor. During deserialization, too large or small integer numbers will be automatically be stored as <code>number_integer_t</code> or <code>number_float_t</code>.</p>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> further states:</p>
<blockquote class="doxtable">
<p>&zwj;Note that when such software is used, numbers that are integers and are in the range $[-2^{53}+1, 2^{53}-1]$ are interoperable in the sense that implementations will agree exactly on their numeric values. </p>
</blockquote>
<p>As this range is a subrange of the exactly supported range [<code>INT64_MIN</code>, <code>INT64_MAX</code>], this class's integer type is interoperable.</p>
<p><a href="https://tools.ietf.org/html/rfc8259">RFC 8259</a> states:</p>
<blockquote class="doxtable">
<p>&zwj;This specification allows implementations to set limits on the range and precision of numbers accepted. Since software that implements IEEE 754-2008 binary64 (double precision) numbers is generally available and widely used, good interoperability can be achieved by implementations that expect no more precision or range than these provide, in the sense that implementations will approximate JSON numbers within the expected precision. </p>
</blockquote>
<p>This implementation does exactly follow this approach, as it uses double precision floating-point numbers. Note values smaller than <code>#!c -1.79769313486232e+308</code> and values greater than <code>#!c 1.79769313486232e+308</code> will be stored as NaN internally and be serialized to <code>#!json null</code>.</p>
<h2><a class="anchor" id="autotoc_md1459"></a>
Storage</h2>
<p>Integer number values, unsigned integer number values, and floating-point number values are stored directly inside a <code><a class="el" href="classbasic__json.html" title="namespace for Niels Lohmann">basic_json</a></code> type. </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.10.0 </li>
  </ul>
</div>
</body>
</html>
